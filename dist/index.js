var i={reset:"\x1B[0m",bright:"\x1B[1m",red:"\x1B[31m",green:"\x1B[32m",yellow:"\x1B[33m",blue:"\x1B[34m",magenta:"\x1B[35m",cyan:"\x1B[36m",white:"\x1B[37m",bgRed:"\x1B[41m",bgGreen:"\x1B[42m",bgYellow:"\x1B[43m",bgBlue:"\x1B[44m",bgMagenta:"\x1B[45m",bgCyan:"\x1B[46m",bgWhite:"\x1B[47m"};function m(u,t,e){let r=[];return r.push(`${i.bright}${i.red}\u274C ERROR:${i.reset} ${i.red}${u}${i.reset}`),t&&r.push(`
${i.blue}\u{1F4CB} Context:${i.reset} ${i.cyan}${t}${i.reset}`),e&&r.push(`
${i.green}\u{1F4A1} Suggestion:${i.reset} ${i.yellow}${e}${i.reset}`),r.join("")}function $(u,t){let e=[];return e.push(`${i.bright}${i.yellow}\u26A0\uFE0F  WARNING:${i.reset} ${i.yellow}${u}${i.reset}`),t&&e.push(`
${i.blue}\u{1F4CB} Context:${i.reset} ${i.cyan}${t}${i.reset}`),e.join("")}function C(u){return`${i.bright}${i.green}\u2705 SUCCESS:${i.reset} ${i.green}${u}${i.reset}`}function x(u){return`${i.bright}${i.blue}\u2139\uFE0F  INFO:${i.reset} ${i.cyan}${u}${i.reset}`}function l(u,t,e,r){let o=`Table ${u} validation failed`,s="";switch(u){case"structure":s="Ensure the table has proper <thead> and <tbody> structure with valid <th> elements";break;case"headers":s=e&&r?`Expected ${e} headers but found ${r}. Check your table header structure.`:"Verify that your table has the expected column headers";break;case"rows":s=e&&r?`Expected ${e} data rows but found ${r}. Check your table data.`:"Verify that your table has the expected number of data rows";break;case"columns":s=e&&r?`Expected ${e} columns but found ${r}. Check your table structure.`:"Verify that your table has the expected number of columns";break;case"cell":s=e&&r?`Expected cell value "${e}" but found "${r}". Check your test data.`:"Verify that the cell contains the expected value";break;case"data":s="Verify that your table data matches the expected structure and values";break}return m(t,o,s)}function p(){return typeof process<"u"&&process.stdout&&process.stdout.isTTY?!0:!(process.env.NO_COLOR||process.env.CI==="true")}function v(u,t,e){if(p())return m(u,t,e);let r=[];return r.push(`ERROR: ${u}`),t&&r.push(`Context: ${t}`),e&&r.push(`Suggestion: ${e}`),r.join(`
`)}var g=class{constructor(t){this.tableLocator=t;this.headers=[];this.headerLocators=[];this.headerToIndexMap=new Map;this.tableVisible=!1}async ensureTableVisible(){this.tableVisible||(await this.tableLocator.waitFor({state:"visible"}),this.tableVisible=!0)}async getHeaders(){return this.headers.length===0&&await this.initializeHeaders(),[...this.headers]}async initializeHeaders(){if(await this.ensureTableVisible(),this.headers.length>0)return;let t=this.tableLocator.locator("thead th, thead td");if(await t.count()===0)throw new Error(l("structure","Table has no header elements. Expected <th> or <td> elements in <thead>."));this.headerLocators=await t.all();let o=(await Promise.all(this.headerLocators.map(async(a,n)=>{try{return{text:(await a.textContent())?.trim()||"",originalIndex:n}}catch(c){return console.warn($(`Failed to extract header at index ${n}: ${c instanceof Error?c.message:"Unknown error"}`,"Header extraction error")),{text:"",originalIndex:n}}}))).filter(a=>a.text.length>0);if(this.headers=o.map(a=>a.text),this.headerToIndexMap.clear(),o.forEach(a=>{this.headerToIndexMap.set(a.text,a.originalIndex)}),this.headers.length===0)throw new Error(l("structure","No valid headers found in table. All headers are empty or failed to extract."));if(new Set(this.headers).size!==this.headers.length){let a=this.headers.filter((n,c)=>this.headers.indexOf(n)!==c);throw new Error(l("headers",`Table contains duplicate header names: ${a.join(", ")}. Headers must be unique.`))}}async findRowByText(t){await this.ensureTableVisible();let e=await this.tableLocator.locator("tbody > tr").all();for(let o of e){if(await o.locator("xpath=ancestor::table[position()>1]").count()>0)continue;let a=await o.textContent();if(a&&(typeof t=="string"?a.includes(t):t.test(a)))return o}let r=await this.getRowCount();throw new Error(l("rows",`No row found matching "${t}". Available rows: ${r}`))}async getCellByHeader(t,e){await this.ensureTableVisible(),this.headers.length===0&&await this.initializeHeaders();let r=this.headerToIndexMap.get(e.trim());if(r===void 0)throw new Error(l("headers",`Header "${e}" not found. Available headers: ${this.headers.join(", ")}`));return t.locator("td").nth(r)}async getCellByIndex(t,e){if(await this.ensureTableVisible(),e<0)throw new Error(l("columns",`Column index ${e} is invalid. Index must be 0 or greater.`,0,e));let r=await t.locator("> td").all(),o=[];for(let a=0;a<r.length;a++){let n=await r[a].textContent();o.push(n||"")}let s=[];for(let a=0;a<r.length;a++){let n=r[a],c=o[a];if(await n.locator("td").count()>0){s.push(n);continue}o.slice(a+1).some(w=>w&&w.trim()&&c.includes(w.trim()))||(c&&c.trim().length>0||s.length>0)&&s.push(n)}if(e>=s.length)throw new Error(l("columns",`Column index ${e} is out of bounds. Row has ${s.length} meaningful columns (valid range: 0 to ${s.length-1}).`,s.length-1,e));return s[e]}async extractTableData(){await this.ensureTableVisible(),this.headers.length===0&&await this.initializeHeaders();let t=await this.tableLocator.locator("tbody > tr").all(),e=[],r=[];for(let o of t)await o.locator("xpath=ancestor::table[position()>1]").count()>0||r.push(o);for(let o of r){let s=await o.locator("> td").all(),a=[];for(let h=0;h<s.length;h++){let d=await s[h].textContent();a.push(d||"")}let n=[];for(let h=0;h<s.length;h++){let d=s[h],w=a[h];if(await d.locator("td").count()>0){n.push(w.trim());continue}a.slice(h+1).some(b=>b&&b.trim()&&w.includes(b.trim()))||(w&&w.trim().length>0||n.length>0)&&n.push(w.trim())}let c={};for(let h=0;h<Math.min(n.length,this.headers.length);h++){let d=this.headers[h],w=n[h];d&&(c[d]=w)}e.push(c)}return{headers:this.headers,rows:e}}async getRowCount(){await this.ensureTableVisible();let t=await this.tableLocator.locator("tbody > tr").all(),e=0;for(let r of t)await r.locator("xpath=ancestor::table[position()>1]").count()>0||e++;return e}async clickCellAction(t,e,r){await this.ensureTableVisible();let o=await this.tableLocator.locator("tbody > tr").all();if(t>=o.length)throw new Error(l("rows",`Row index ${t} is out of bounds. Table has ${o.length} rows.`,o.length-1,t));let s=o[t],n=(await this.getCellByHeader(s,e)).locator(r);if(await n.count()===0)throw new Error(l("cell",`No action element found matching selector "${r}" in cell at row ${t}, column "${e}".`));await n.first().click()}};var f=class{constructor(t){this.tableInteractor=t}async assertRowCount(t,e){let r=await this.tableInteractor.getRowCount();if(r!==t){let o=e||l("rows",`Expected table to have ${t} rows, but found ${r} rows.`,t,r);throw new Error(o)}}async assertColumnCount(t,e){let o=(await this.tableInteractor.getHeaders()).length;if(o!==t){let s=e||l("columns",`Expected table to have ${t} columns, but found ${o} columns.`,t,o);throw new Error(s)}}async assertCellValue(t,e,r,o){let s=await this.tableInteractor.extractTableData();if(t>=s.rows.length){let c=l("rows",`Row index ${t} is out of bounds. Table has ${s.rows.length} rows.`,void 0,s.rows.length);throw new Error(c)}let n=s.rows[t][e];if(n===void 0){let c=l("headers",`Header "${e}" not found in table. Available headers: ${s.headers.join(", ")}`);throw new Error(c)}if(n!==r){let c=o||l("cell",`Expected cell value "${r}" but found "${n}" at row ${t}, column "${e}".`,r,n);throw new Error(c)}}async assertRowExists(t,e){try{await this.tableInteractor.findRowByText(t)}catch{let o=e||l("rows",`Expected to find a row containing "${t}", but no such row exists.`);throw new Error(o)}}async assertRowDoesNotExist(t,e){try{await this.tableInteractor.findRowByText(t);let r=e||l("rows",`Expected no row to contain "${t}", but found a matching row.`);throw new Error(r)}catch(r){if(r instanceof Error&&r.message.includes("No row found"))return;throw r}}async assertColumnExists(t,e){let r=await this.tableInteractor.getHeaders();if(!r.includes(t)){let o=e||l("headers",`Expected column "${t}" to exist, but it was not found. Available columns: ${r.join(", ")}`);throw new Error(o)}}async assertHeaders(t,e){let r=await this.tableInteractor.getHeaders();if(r.length!==t.length){let o=e||l("headers",`Expected ${t.length} headers but found ${r.length}. Expected: [${t.join(", ")}], Actual: [${r.join(", ")}]`,t.length,r.length);throw new Error(o)}for(let o=0;o<t.length;o++)if(r[o]!==t[o]){let s=e||l("headers",`Header mismatch at position ${o}. Expected "${t[o]}" but found "${r[o]}".`,t[o],r[o]);throw new Error(s)}}async assertTableData(t,e){let r=await this.tableInteractor.extractTableData();await this.assertHeaders(t.headers,e),await this.assertRowCount(t.rows.length,e);for(let o=0;o<t.rows.length;o++){let s=t.rows[o],a=r.rows[o];for(let[n,c]of Object.entries(s)){let h=a[n];if(h!==c){let d=e||l("data",`Data mismatch at row ${o}, column "${n}". Expected "${c}" but found "${h}".`,c,h);throw new Error(d)}}}}async assertTableIsEmpty(t){let e=await this.tableInteractor.getRowCount();if(e>0){let r=t||l("rows",`Expected table to be empty but found ${e} data rows.`);throw new Error(r)}}async assertTableIsNotEmpty(t){if(await this.tableInteractor.getRowCount()===0){let r=t||l("rows","Expected table to have data rows but table is empty.");throw new Error(r)}}async assertColumnValues(t,e,r){let o=await this.tableInteractor.extractTableData();if(!o.headers.includes(t)){let a=l("headers",`Column "${t}" not found. Available columns: ${o.headers.join(", ")}`);throw new Error(a)}let s=o.rows.map(a=>a[t]);if(s.length!==e.length){let a=r||l("rows",`Expected ${e.length} values in column "${t}" but found ${s.length}.`,e.length,s.length);throw new Error(a)}for(let a=0;a<e.length;a++)if(s[a]!==e[a]){let n=r||l("cell",`Value mismatch in column "${t}" at row ${a}. Expected "${e[a]}" but found "${s[a]}".`,e[a],s[a]);throw new Error(n)}}async assertCellMatchesRegex(t,e,r,o){let s=await this.tableInteractor.extractTableData();if(t>=s.rows.length){let c=l("rows",`Row index ${t} is out of bounds. Table has ${s.rows.length} rows.`,void 0,s.rows.length);throw new Error(c)}let n=s.rows[t][e];if(n===void 0){let c=l("headers",`Header "${e}" not found in table. Available headers: ${s.headers.join(", ")}`);throw new Error(c)}if(!r.test(n)){let c=o||l("cell",`Cell value "${n}" at row ${t}, column "${e}" does not match regex ${r}.`,r.toString(),n);throw new Error(c)}}async assertTableStructure(t){try{if((await this.tableInteractor.getHeaders()).length===0){let r=l("structure","Table has no valid headers.");throw new Error(r)}}catch(e){let r=t||l("structure",`Table structure is invalid: ${e instanceof Error?e.message:"Unknown error"}`);throw new Error(r)}}};export{f as TableAssertions,g as TableInteractor,m as createColoredError,x as createColoredInfo,C as createColoredSuccess,$ as createColoredWarning,v as createSmartError,l as createTableError,p as supportsColors};
